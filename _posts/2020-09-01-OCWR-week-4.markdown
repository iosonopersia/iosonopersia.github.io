---
layout: post
title:  "[OCWR] Week 4 - OpenCitations Weekly Report"
date:   2020-09-01 20:50:00 +0200
categories: blog ocwr
---
# Introduction
During the fourth week I continued working on the [oc_graphlib project][oc_graphlib_github].
  * I fixed some issues in the source code
  * I completed the code refactoring of `dataset.py` and `distribution.py` (which will be added to the online repository as soon as possible)
  * I verified that the `oc_graphlib` package can be used in place of the original `graphlib.py` module without causing integration errors
    with the CCC workflow (namely the BEE and the SPACIN software)
  * I setup and built an html documentation using [Sphinx][sphinx]
  * I started working on the next phase of the project, which is related to the redesign of the provenance layer

# Report

## Fixed some issues
Firstly, I checked the entire codebase of `oc_graphlib` while comparing it with the documentation provided by the [OCDM][ocdm-2.0.1], looking
for potential implementation mistakes. I found the following two methods, both added last week, whose parameter was of the type `str` whilst it 
should have been of type `URIRef`, since the documentation refers neither to a `literal` nor to a `string`.

__ResourceEmbodiment__
  * has_url
  * has_media_type

Moreover, I found some little inconsistencies in the [OCDM][ocdm-2.0.1] itself, which I signalled by opening some GitHub issues ([#3][issue3], [#4][issue4], [#5][issue5], [#6][issue6]) in the [opencitations/metadata repository][metadata_repo].

## Dataset and Distribution code cleaning
I finished cleaning up `Dataset` and `Distribution` classes, moving some functions into the right class and documenting every method with short 
comments. The `Distribution` class now internally works in a very similar fashion to the other classes of [oc_graphlib][oc_graphlib_github],
storing its `URIRef` reference as `self.res`.

## Integration test with BEE and SPACIN
I decided to run a test to verify whether the [oc_graphlib][oc_graphlib_github] package could have been used as a drop-in replacement for the 
original `graphlib.py` module. In the [CCC repository][ccc] where it's located, `graphlib.py` is used primarily by [SPACIN][spacin]. In the 
OpenCitations workflow, SPACIN is a software which is intended to be launched with (or after) another software called [BEE][bee]. Hence, I
cloned the [CCC repository][ccc] locally and I removed from it the file `graphlib.py`. Then, I changed every import statement from within SPACIN 
and BEE source files in order for them to point at the globally installed `oc_graphlib` package. When everything was ready, I firstly launched 
BEE to produce the JSON-LD files that SPACIN consumes and then I launched SPACIN itself, hoping everything will run smoothly without throwing
exceptions. In the end, I got 3 different exceptions:
  1. the first one was caused by a very little bug in the `ProvSet` class, which I fixed immediately with [this commit][self_g_prov_commit]
  2. the second exception was thrown because the `jats2oc.py` module from SPACIN assumes that `DiscourseElement` objects have a "create_number" method [see jats2oc.py, line 1666][jats2oc_1666] (while this is not documented in the [OCDM][ocdm-2.0.1])
  3. the third exception was thrown because the `jats2oc.py` module from SPACIN assumes that `ReferencePointer` objects have a "has_next_de" method [see jats2oc.py, line 1568][jats2oc_1568] (while the `ReferencePointer` class already has a "has_next_rp" method which does the same thing)

While the first one was already fixed and the third one should be easily fixed just by changing line 1568 of `jats2oc.py` from
``` python
    cur_rp.has_next_de(next_rp)
```
to
``` python
    cur_rp.has_next_rp(next_rp)
```
, the second one requires a review of the [OCDM][ocdm-2.0.1] to be properly handled.

## Documentation provided by Sphinx
As far as the documentation is concerned, I choosed to try `Sphinx`, a tool which provides an automated way for building a documentation. It 
permits to automatically extract docstrings from the code and to export the documentation in a variety of different formats, such as HTML, PDF 
and LaTex. I prepared the [oc_graphlib repo][oc_graphlib_github] in such a way that any developer could locally build the documentation 
while working on it and could later submit his/her contributions to the public repository. I obviously updated the `README.md` file of the 
project to explain how to properly work with the documentation.

I also continued to add docstrings to the project, grabbing the explanations provided for each method by the [OCDM specification][ocdm-2.0.1]
itself.

## Looking for a technique to randomly access a line inside a text file with O(1) complexity
I started working for the first time on the provenance layer: my initial task is to find an efficient way to handle the integer counters
needed to keep track of the last snapshot number of each entity stored in the OpenCitations Context Corpus. This is now done in a little
convoluted way: for each type of entity ("an", "be", "br", "rp", "ci", ...), the long list of integer numbers related to each instance of it
is splitted and stored in multiple text files. Each text file has a line for every instance containing the decimal representation of the actual
value of the respective counter. To retrieve and -- eventually -- modify a line, the file is read sequentially line by line: this is not a 
problem as far as the size of each file is kept small.

Exploring the possibility of simplifying this mechanism by using only one text file for each type of entity, I had to find a way to efficiently
retrieve a random line from a huge file, beating the performances of a sequential search. Having deeply studied the case, I came out with
a simple solution that I believe should be evaluated as an alternative to the current strategy.

What's required is a text file with the same byte length for each line. I created a Python script which generates such a file using random 
numbers and writing 700 million lines of 4 ASCII characters each (the fourth is reserved for the `\n` character). If the decimal representation
of the counter value is shorter than 3 chars, the remaining slots are filled with a special character (for example a blank space). Then, a line 
in the middle of the file (from 1 to 700M) is randomly choosen. The script then tries to retrieve the respective counter value firstly with a 
sequential search and secondly with a different algorithm that exploits the `seek` method of the Python's `File` class (moving the I/O pointer 
directly to `line_number * line_length` byte, where the correct line starts). Some quick tests showed that the latter strategy proves to be 
optimal when the file is big in size, otherwise the OS cache often covers pretty well the weaknesses of the sequential search (making it the 
fastest strategy).

The "seek and read" strategy enjoys a O(1) complexity, requiring a constant access time to each line of the file, making it quite suitable
for our job. __As as potential drawback, particular attention must be kept by human agents that want to interact with the text file, since they must be sure not to change the lenght of any line as they would skew every reading from that point on.__

[oc_graphlib_github]:  https://github.com/iosonopersia/oc_graphlib
[ocdm-2.0.1]:          https://figshare.com/articles/Metadata_for_the_OpenCitations_Corpus/3443876
[metadata_repo]:       https://github.com/opencitations/metadata
[sphinx]:              https://www.sphinx-doc.org/en/master/
[issue3]:              https://github.com/opencitations/metadata/issues/3
[issue4]:              https://github.com/opencitations/metadata/issues/4
[issue5]:              https://github.com/opencitations/metadata/issues/5
[issue6]:              https://github.com/opencitations/metadata/issues/6
[ccc]:                 https://github.com/opencitations/ccc
[spacin]:              https://github.com/opencitations/script/tree/master/spacin
[bee]:                 https://github.com/opencitations/script/tree/master/bee
[self_g_prov_commit]:  https://github.com/iosonopersia/oc_graphlib/commit/425f8e3ad9b9073e1d8d9ae7e6a1651aaa4df552
[jats2oc_1666]:        https://github.com/opencitations/ccc/blob/94820fc31eb2529eae127166b3f1c8316283529e/scripts/script/ccc/jats2oc.py#L1666
[jats2oc_1568]:        https://github.com/opencitations/ccc/blob/94820fc31eb2529eae127166b3f1c8316283529e/scripts/script/ccc/jats2oc.py#L1568
